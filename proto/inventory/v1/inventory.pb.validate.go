// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: inventory/v1/inventory.proto

package inventoryv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Product with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Product) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Product with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProductMultiError, or nil if none found.
func (m *Product) ValidateAll() error {
	return m.validate(true)
}

func (m *Product) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVendorId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "VendorId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "VendorId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVendorId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductValidationError{
				field:  "VendorId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetSku()); l < 1 || l > 64 {
		err := ProductValidationError{
			field:  "Sku",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := ProductValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) > 4128 {
		err := ProductValidationError{
			field:  "Description",
			reason: "value length must be at most 4128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPriceCents() < 0 {
		err := ProductValidationError{
			field:  "PriceCents",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCurrencyCode()) != 3 {
		err := ProductValidationError{
			field:  "CurrencyCode",
			reason: "value length must be 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	// no validation rules for IsActive

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductMultiError(errors)
	}

	return nil
}

// ProductMultiError is an error wrapping multiple validation errors returned
// by Product.ValidateAll() if the designated constraints aren't met.
type ProductMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductMultiError) AllErrors() []error { return m }

// ProductValidationError is the validation error returned by Product.Validate
// if the designated constraints aren't met.
type ProductValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductValidationError) ErrorName() string { return "ProductValidationError" }

// Error satisfies the builtin error interface
func (e ProductValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProduct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductValidationError{}

// Validate checks the field values on ProductInput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductInput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductInputMultiError, or
// nil if none found.
func (m *ProductInput) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetSku()); l < 1 || l > 64 {
		err := ProductInputValidationError{
			field:  "Sku",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := ProductInputValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) > 4128 {
		err := ProductInputValidationError{
			field:  "Description",
			reason: "value length must be at most 4128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPriceCents() < 0 {
		err := ProductInputValidationError{
			field:  "PriceCents",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCurrencyCode()) != 3 {
		err := ProductInputValidationError{
			field:  "CurrencyCode",
			reason: "value length must be 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	// no validation rules for IsActive

	if len(errors) > 0 {
		return ProductInputMultiError(errors)
	}

	return nil
}

// ProductInputMultiError is an error wrapping multiple validation errors
// returned by ProductInput.ValidateAll() if the designated constraints aren't met.
type ProductInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductInputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductInputMultiError) AllErrors() []error { return m }

// ProductInputValidationError is the validation error returned by
// ProductInput.Validate if the designated constraints aren't met.
type ProductInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductInputValidationError) ErrorName() string { return "ProductInputValidationError" }

// Error satisfies the builtin error interface
func (e ProductInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductInputValidationError{}

// Validate checks the field values on ProductPatch with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductPatch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductPatch with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductPatchMultiError, or
// nil if none found.
func (m *ProductPatch) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductPatch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if wrapper := m.GetSku(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 1 || l > 64 {
			err := ProductPatchValidationError{
				field:  "Sku",
				reason: "value length must be between 1 and 64 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if wrapper := m.GetName(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 1 || l > 255 {
			err := ProductPatchValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 255 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if utf8.RuneCountInString(wrapper.GetValue()) > 4128 {
			err := ProductPatchValidationError{
				field:  "Description",
				reason: "value length must be at most 4128 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if wrapper := m.GetPriceCents(); wrapper != nil {

		if wrapper.GetValue() < 0 {
			err := ProductPatchValidationError{
				field:  "PriceCents",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if wrapper := m.GetCurrencyCode(); wrapper != nil {

		if utf8.RuneCountInString(wrapper.GetValue()) != 3 {
			err := ProductPatchValidationError{
				field:  "CurrencyCode",
				reason: "value length must be 3 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)

		}

	}

	if all {
		switch v := interface{}(m.GetIsActive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductPatchValidationError{
					field:  "IsActive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductPatchValidationError{
					field:  "IsActive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsActive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductPatchValidationError{
				field:  "IsActive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductPatchMultiError(errors)
	}

	return nil
}

// ProductPatchMultiError is an error wrapping multiple validation errors
// returned by ProductPatch.ValidateAll() if the designated constraints aren't met.
type ProductPatchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductPatchMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductPatchMultiError) AllErrors() []error { return m }

// ProductPatchValidationError is the validation error returned by
// ProductPatch.Validate if the designated constraints aren't met.
type ProductPatchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductPatchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductPatchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductPatchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductPatchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductPatchValidationError) ErrorName() string { return "ProductPatchValidationError" }

// Error satisfies the builtin error interface
func (e ProductPatchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductPatch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductPatchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductPatchValidationError{}

// Validate checks the field values on CreateProductRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateProductRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProductRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProductRequestMultiError, or nil if none found.
func (m *CreateProductRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProductRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProduct() == nil {
		err := CreateProductRequestValidationError{
			field:  "Product",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProduct()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateProductRequestValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateProductRequestValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProduct()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateProductRequestValidationError{
				field:  "Product",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateProductRequestMultiError(errors)
	}

	return nil
}

// CreateProductRequestMultiError is an error wrapping multiple validation
// errors returned by CreateProductRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateProductRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProductRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProductRequestMultiError) AllErrors() []error { return m }

// CreateProductRequestValidationError is the validation error returned by
// CreateProductRequest.Validate if the designated constraints aren't met.
type CreateProductRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProductRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProductRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProductRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProductRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProductRequestValidationError) ErrorName() string {
	return "CreateProductRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProductRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProductRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProductRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProductRequestValidationError{}

// Validate checks the field values on CreateProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateProductResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProductResponseMultiError, or nil if none found.
func (m *CreateProductResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProductResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProduct()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateProductResponseValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateProductResponseValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProduct()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateProductResponseValidationError{
				field:  "Product",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateProductResponseMultiError(errors)
	}

	return nil
}

// CreateProductResponseMultiError is an error wrapping multiple validation
// errors returned by CreateProductResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateProductResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProductResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProductResponseMultiError) AllErrors() []error { return m }

// CreateProductResponseValidationError is the validation error returned by
// CreateProductResponse.Validate if the designated constraints aren't met.
type CreateProductResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProductResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProductResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProductResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProductResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProductResponseValidationError) ErrorName() string {
	return "CreateProductResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProductResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProductResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProductResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProductResponseValidationError{}

// Validate checks the field values on UpdateProductRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProductRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProductRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProductRequestMultiError, or nil if none found.
func (m *UpdateProductRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProductRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProductId() == nil {
		err := UpdateProductRequestValidationError{
			field:  "ProductId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProductRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProductRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProductRequestValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPatch() == nil {
		err := UpdateProductRequestValidationError{
			field:  "Patch",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPatch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProductRequestValidationError{
					field:  "Patch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProductRequestValidationError{
					field:  "Patch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPatch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProductRequestValidationError{
				field:  "Patch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateProductRequestMultiError(errors)
	}

	return nil
}

// UpdateProductRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateProductRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateProductRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProductRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProductRequestMultiError) AllErrors() []error { return m }

// UpdateProductRequestValidationError is the validation error returned by
// UpdateProductRequest.Validate if the designated constraints aren't met.
type UpdateProductRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProductRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProductRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProductRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProductRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProductRequestValidationError) ErrorName() string {
	return "UpdateProductRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProductRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProductRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProductRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProductRequestValidationError{}

// Validate checks the field values on UpdateProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProductResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProductResponseMultiError, or nil if none found.
func (m *UpdateProductResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProductResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProduct()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProductResponseValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProductResponseValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProduct()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProductResponseValidationError{
				field:  "Product",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateProductResponseMultiError(errors)
	}

	return nil
}

// UpdateProductResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateProductResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateProductResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProductResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProductResponseMultiError) AllErrors() []error { return m }

// UpdateProductResponseValidationError is the validation error returned by
// UpdateProductResponse.Validate if the designated constraints aren't met.
type UpdateProductResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProductResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProductResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProductResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProductResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProductResponseValidationError) ErrorName() string {
	return "UpdateProductResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProductResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProductResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProductResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProductResponseValidationError{}

// Validate checks the field values on DeleteProductRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteProductRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteProductRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteProductRequestMultiError, or nil if none found.
func (m *DeleteProductRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteProductRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProductId() == nil {
		err := DeleteProductRequestValidationError{
			field:  "ProductId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteProductRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteProductRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteProductRequestValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteProductRequestMultiError(errors)
	}

	return nil
}

// DeleteProductRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteProductRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteProductRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteProductRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteProductRequestMultiError) AllErrors() []error { return m }

// DeleteProductRequestValidationError is the validation error returned by
// DeleteProductRequest.Validate if the designated constraints aren't met.
type DeleteProductRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteProductRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteProductRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteProductRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteProductRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteProductRequestValidationError) ErrorName() string {
	return "DeleteProductRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteProductRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteProductRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteProductRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteProductRequestValidationError{}

// Validate checks the field values on GetProductRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetProductRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProductRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProductRequestMultiError, or nil if none found.
func (m *GetProductRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProductRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProductId() == nil {
		err := GetProductRequestValidationError{
			field:  "ProductId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProductRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProductRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProductRequestValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetProductRequestMultiError(errors)
	}

	return nil
}

// GetProductRequestMultiError is an error wrapping multiple validation errors
// returned by GetProductRequest.ValidateAll() if the designated constraints
// aren't met.
type GetProductRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProductRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProductRequestMultiError) AllErrors() []error { return m }

// GetProductRequestValidationError is the validation error returned by
// GetProductRequest.Validate if the designated constraints aren't met.
type GetProductRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProductRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProductRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProductRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProductRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProductRequestValidationError) ErrorName() string {
	return "GetProductRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetProductRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProductRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProductRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProductRequestValidationError{}

// Validate checks the field values on GetProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProductResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProductResponseMultiError, or nil if none found.
func (m *GetProductResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProductResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProduct()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProductResponseValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProductResponseValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProduct()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProductResponseValidationError{
				field:  "Product",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetProductResponseMultiError(errors)
	}

	return nil
}

// GetProductResponseMultiError is an error wrapping multiple validation errors
// returned by GetProductResponse.ValidateAll() if the designated constraints
// aren't met.
type GetProductResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProductResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProductResponseMultiError) AllErrors() []error { return m }

// GetProductResponseValidationError is the validation error returned by
// GetProductResponse.Validate if the designated constraints aren't met.
type GetProductResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProductResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProductResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProductResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProductResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProductResponseValidationError) ErrorName() string {
	return "GetProductResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetProductResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProductResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProductResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProductResponseValidationError{}

// Validate checks the field values on ListProductsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProductsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProductsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProductsRequestMultiError, or nil if none found.
func (m *ListProductsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProductsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVendorId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProductsRequestValidationError{
					field:  "VendorId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProductsRequestValidationError{
					field:  "VendorId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVendorId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProductsRequestValidationError{
				field:  "VendorId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetQuery()); l < 1 || l > 255 {
		err := ListProductsRequestValidationError{
			field:  "Query",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OnlyActive

	if val := m.GetLimit(); val < 1 || val > 100 {
		err := ListProductsRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := ListProductsRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListProductsRequestMultiError(errors)
	}

	return nil
}

// ListProductsRequestMultiError is an error wrapping multiple validation
// errors returned by ListProductsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListProductsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProductsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProductsRequestMultiError) AllErrors() []error { return m }

// ListProductsRequestValidationError is the validation error returned by
// ListProductsRequest.Validate if the designated constraints aren't met.
type ListProductsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProductsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProductsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProductsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProductsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProductsRequestValidationError) ErrorName() string {
	return "ListProductsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProductsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProductsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProductsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProductsRequestValidationError{}

// Validate checks the field values on ListProductsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProductsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProductsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProductsResponseMultiError, or nil if none found.
func (m *ListProductsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProductsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProducts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProductsResponseValidationError{
						field:  fmt.Sprintf("Products[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProductsResponseValidationError{
						field:  fmt.Sprintf("Products[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProductsResponseValidationError{
					field:  fmt.Sprintf("Products[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for NextOffset

	if len(errors) > 0 {
		return ListProductsResponseMultiError(errors)
	}

	return nil
}

// ListProductsResponseMultiError is an error wrapping multiple validation
// errors returned by ListProductsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListProductsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProductsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProductsResponseMultiError) AllErrors() []error { return m }

// ListProductsResponseValidationError is the validation error returned by
// ListProductsResponse.Validate if the designated constraints aren't met.
type ListProductsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProductsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProductsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProductsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProductsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProductsResponseValidationError) ErrorName() string {
	return "ListProductsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListProductsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProductsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProductsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProductsResponseValidationError{}

// Validate checks the field values on BatchGetProductsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetProductsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetProductsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetProductsRequestMultiError, or nil if none found.
func (m *BatchGetProductsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetProductsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetProductIds()) < 1 {
		err := BatchGetProductsRequestValidationError{
			field:  "ProductIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetProductIds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchGetProductsRequestValidationError{
						field:  fmt.Sprintf("ProductIds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchGetProductsRequestValidationError{
						field:  fmt.Sprintf("ProductIds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchGetProductsRequestValidationError{
					field:  fmt.Sprintf("ProductIds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchGetProductsRequestMultiError(errors)
	}

	return nil
}

// BatchGetProductsRequestMultiError is an error wrapping multiple validation
// errors returned by BatchGetProductsRequest.ValidateAll() if the designated
// constraints aren't met.
type BatchGetProductsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetProductsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetProductsRequestMultiError) AllErrors() []error { return m }

// BatchGetProductsRequestValidationError is the validation error returned by
// BatchGetProductsRequest.Validate if the designated constraints aren't met.
type BatchGetProductsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetProductsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetProductsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetProductsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetProductsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetProductsRequestValidationError) ErrorName() string {
	return "BatchGetProductsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetProductsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetProductsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetProductsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetProductsRequestValidationError{}

// Validate checks the field values on BatchGetProductsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetProductsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetProductsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetProductsResponseMultiError, or nil if none found.
func (m *BatchGetProductsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetProductsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProducts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchGetProductsResponseValidationError{
						field:  fmt.Sprintf("Products[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchGetProductsResponseValidationError{
						field:  fmt.Sprintf("Products[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchGetProductsResponseValidationError{
					field:  fmt.Sprintf("Products[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchGetProductsResponseMultiError(errors)
	}

	return nil
}

// BatchGetProductsResponseMultiError is an error wrapping multiple validation
// errors returned by BatchGetProductsResponse.ValidateAll() if the designated
// constraints aren't met.
type BatchGetProductsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetProductsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetProductsResponseMultiError) AllErrors() []error { return m }

// BatchGetProductsResponseValidationError is the validation error returned by
// BatchGetProductsResponse.Validate if the designated constraints aren't met.
type BatchGetProductsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetProductsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetProductsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetProductsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetProductsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetProductsResponseValidationError) ErrorName() string {
	return "BatchGetProductsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetProductsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetProductsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetProductsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetProductsResponseValidationError{}

// Validate checks the field values on Stock with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Stock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Stock with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StockMultiError, or nil if none found.
func (m *Stock) ValidateAll() error {
	return m.validate(true)
}

func (m *Stock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StockValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StockValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StockValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Available

	// no validation rules for Reserved

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StockValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StockValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StockValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StockMultiError(errors)
	}

	return nil
}

// StockMultiError is an error wrapping multiple validation errors returned by
// Stock.ValidateAll() if the designated constraints aren't met.
type StockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StockMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StockMultiError) AllErrors() []error { return m }

// StockValidationError is the validation error returned by Stock.Validate if
// the designated constraints aren't met.
type StockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StockValidationError) ErrorName() string { return "StockValidationError" }

// Error satisfies the builtin error interface
func (e StockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StockValidationError{}

// Validate checks the field values on GetStockRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetStockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStockRequestMultiError, or nil if none found.
func (m *GetStockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProductId() == nil {
		err := GetStockRequestValidationError{
			field:  "ProductId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetStockRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetStockRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetStockRequestValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetStockRequestMultiError(errors)
	}

	return nil
}

// GetStockRequestMultiError is an error wrapping multiple validation errors
// returned by GetStockRequest.ValidateAll() if the designated constraints
// aren't met.
type GetStockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStockRequestMultiError) AllErrors() []error { return m }

// GetStockRequestValidationError is the validation error returned by
// GetStockRequest.Validate if the designated constraints aren't met.
type GetStockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStockRequestValidationError) ErrorName() string { return "GetStockRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetStockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStockRequestValidationError{}

// Validate checks the field values on GetStockResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetStockResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStockResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStockResponseMultiError, or nil if none found.
func (m *GetStockResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStockResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStock()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetStockResponseValidationError{
					field:  "Stock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetStockResponseValidationError{
					field:  "Stock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStock()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetStockResponseValidationError{
				field:  "Stock",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetStockResponseMultiError(errors)
	}

	return nil
}

// GetStockResponseMultiError is an error wrapping multiple validation errors
// returned by GetStockResponse.ValidateAll() if the designated constraints
// aren't met.
type GetStockResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStockResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStockResponseMultiError) AllErrors() []error { return m }

// GetStockResponseValidationError is the validation error returned by
// GetStockResponse.Validate if the designated constraints aren't met.
type GetStockResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStockResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStockResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStockResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStockResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStockResponseValidationError) ErrorName() string { return "GetStockResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetStockResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStockResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStockResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStockResponseValidationError{}

// Validate checks the field values on SetStockRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetStockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetStockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetStockRequestMultiError, or nil if none found.
func (m *SetStockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetStockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProductId() == nil {
		err := SetStockRequestValidationError{
			field:  "ProductId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetStockRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetStockRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetStockRequestValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAvailable() < 0 {
		err := SetStockRequestValidationError{
			field:  "Available",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SetStockRequestMultiError(errors)
	}

	return nil
}

// SetStockRequestMultiError is an error wrapping multiple validation errors
// returned by SetStockRequest.ValidateAll() if the designated constraints
// aren't met.
type SetStockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetStockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetStockRequestMultiError) AllErrors() []error { return m }

// SetStockRequestValidationError is the validation error returned by
// SetStockRequest.Validate if the designated constraints aren't met.
type SetStockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetStockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetStockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetStockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetStockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetStockRequestValidationError) ErrorName() string { return "SetStockRequestValidationError" }

// Error satisfies the builtin error interface
func (e SetStockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetStockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetStockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetStockRequestValidationError{}

// Validate checks the field values on SetStockResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetStockResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetStockResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetStockResponseMultiError, or nil if none found.
func (m *SetStockResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SetStockResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStock()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetStockResponseValidationError{
					field:  "Stock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetStockResponseValidationError{
					field:  "Stock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStock()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetStockResponseValidationError{
				field:  "Stock",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetStockResponseMultiError(errors)
	}

	return nil
}

// SetStockResponseMultiError is an error wrapping multiple validation errors
// returned by SetStockResponse.ValidateAll() if the designated constraints
// aren't met.
type SetStockResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetStockResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetStockResponseMultiError) AllErrors() []error { return m }

// SetStockResponseValidationError is the validation error returned by
// SetStockResponse.Validate if the designated constraints aren't met.
type SetStockResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetStockResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetStockResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetStockResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetStockResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetStockResponseValidationError) ErrorName() string { return "SetStockResponseValidationError" }

// Error satisfies the builtin error interface
func (e SetStockResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetStockResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetStockResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetStockResponseValidationError{}

// Validate checks the field values on AdjustStockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdjustStockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdjustStockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdjustStockRequestMultiError, or nil if none found.
func (m *AdjustStockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AdjustStockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProductId() == nil {
		err := AdjustStockRequestValidationError{
			field:  "ProductId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdjustStockRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdjustStockRequestValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdjustStockRequestValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Delta

	if len(errors) > 0 {
		return AdjustStockRequestMultiError(errors)
	}

	return nil
}

// AdjustStockRequestMultiError is an error wrapping multiple validation errors
// returned by AdjustStockRequest.ValidateAll() if the designated constraints
// aren't met.
type AdjustStockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdjustStockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdjustStockRequestMultiError) AllErrors() []error { return m }

// AdjustStockRequestValidationError is the validation error returned by
// AdjustStockRequest.Validate if the designated constraints aren't met.
type AdjustStockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdjustStockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdjustStockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdjustStockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdjustStockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdjustStockRequestValidationError) ErrorName() string {
	return "AdjustStockRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AdjustStockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdjustStockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdjustStockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdjustStockRequestValidationError{}

// Validate checks the field values on AdjustStockResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdjustStockResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdjustStockResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdjustStockResponseMultiError, or nil if none found.
func (m *AdjustStockResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AdjustStockResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStock()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdjustStockResponseValidationError{
					field:  "Stock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdjustStockResponseValidationError{
					field:  "Stock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStock()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdjustStockResponseValidationError{
				field:  "Stock",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdjustStockResponseMultiError(errors)
	}

	return nil
}

// AdjustStockResponseMultiError is an error wrapping multiple validation
// errors returned by AdjustStockResponse.ValidateAll() if the designated
// constraints aren't met.
type AdjustStockResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdjustStockResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdjustStockResponseMultiError) AllErrors() []error { return m }

// AdjustStockResponseValidationError is the validation error returned by
// AdjustStockResponse.Validate if the designated constraints aren't met.
type AdjustStockResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdjustStockResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdjustStockResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdjustStockResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdjustStockResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdjustStockResponseValidationError) ErrorName() string {
	return "AdjustStockResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AdjustStockResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdjustStockResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdjustStockResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdjustStockResponseValidationError{}

// Validate checks the field values on ReserveItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReserveItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReserveItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReserveItemMultiError, or
// nil if none found.
func (m *ReserveItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ReserveItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProductId() == nil {
		err := ReserveItemValidationError{
			field:  "ProductId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReserveItemValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReserveItemValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReserveItemValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetQuantity() <= 0 {
		err := ReserveItemValidationError{
			field:  "Quantity",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ReserveItemMultiError(errors)
	}

	return nil
}

// ReserveItemMultiError is an error wrapping multiple validation errors
// returned by ReserveItem.ValidateAll() if the designated constraints aren't met.
type ReserveItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReserveItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReserveItemMultiError) AllErrors() []error { return m }

// ReserveItemValidationError is the validation error returned by
// ReserveItem.Validate if the designated constraints aren't met.
type ReserveItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReserveItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReserveItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReserveItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReserveItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReserveItemValidationError) ErrorName() string { return "ReserveItemValidationError" }

// Error satisfies the builtin error interface
func (e ReserveItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReserveItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReserveItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReserveItemValidationError{}

// Validate checks the field values on ReserveRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReserveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReserveRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReserveRequestMultiError,
// or nil if none found.
func (m *ReserveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReserveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOrderId() == nil {
		err := ReserveRequestValidationError{
			field:  "OrderId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOrderId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReserveRequestValidationError{
					field:  "OrderId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReserveRequestValidationError{
					field:  "OrderId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReserveRequestValidationError{
				field:  "OrderId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetItems()) < 1 {
		err := ReserveRequestValidationError{
			field:  "Items",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReserveRequestValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReserveRequestValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReserveRequestValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReserveRequestMultiError(errors)
	}

	return nil
}

// ReserveRequestMultiError is an error wrapping multiple validation errors
// returned by ReserveRequest.ValidateAll() if the designated constraints
// aren't met.
type ReserveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReserveRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReserveRequestMultiError) AllErrors() []error { return m }

// ReserveRequestValidationError is the validation error returned by
// ReserveRequest.Validate if the designated constraints aren't met.
type ReserveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReserveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReserveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReserveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReserveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReserveRequestValidationError) ErrorName() string { return "ReserveRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReserveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReserveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReserveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReserveRequestValidationError{}

// Validate checks the field values on ReserveOkItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReserveOkItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReserveOkItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReserveOkItemMultiError, or
// nil if none found.
func (m *ReserveOkItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ReserveOkItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReserveOkItemValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReserveOkItemValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReserveOkItemValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	if len(errors) > 0 {
		return ReserveOkItemMultiError(errors)
	}

	return nil
}

// ReserveOkItemMultiError is an error wrapping multiple validation errors
// returned by ReserveOkItem.ValidateAll() if the designated constraints
// aren't met.
type ReserveOkItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReserveOkItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReserveOkItemMultiError) AllErrors() []error { return m }

// ReserveOkItemValidationError is the validation error returned by
// ReserveOkItem.Validate if the designated constraints aren't met.
type ReserveOkItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReserveOkItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReserveOkItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReserveOkItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReserveOkItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReserveOkItemValidationError) ErrorName() string { return "ReserveOkItemValidationError" }

// Error satisfies the builtin error interface
func (e ReserveOkItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReserveOkItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReserveOkItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReserveOkItemValidationError{}

// Validate checks the field values on ReserveFailedItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReserveFailedItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReserveFailedItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReserveFailedItemMultiError, or nil if none found.
func (m *ReserveFailedItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ReserveFailedItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProductId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReserveFailedItemValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReserveFailedItemValidationError{
					field:  "ProductId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReserveFailedItemValidationError{
				field:  "ProductId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Requested

	if utf8.RuneCountInString(m.GetReason()) > 200 {
		err := ReserveFailedItemValidationError{
			field:  "Reason",
			reason: "value length must be at most 200 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ReserveFailedItemMultiError(errors)
	}

	return nil
}

// ReserveFailedItemMultiError is an error wrapping multiple validation errors
// returned by ReserveFailedItem.ValidateAll() if the designated constraints
// aren't met.
type ReserveFailedItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReserveFailedItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReserveFailedItemMultiError) AllErrors() []error { return m }

// ReserveFailedItemValidationError is the validation error returned by
// ReserveFailedItem.Validate if the designated constraints aren't met.
type ReserveFailedItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReserveFailedItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReserveFailedItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReserveFailedItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReserveFailedItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReserveFailedItemValidationError) ErrorName() string {
	return "ReserveFailedItemValidationError"
}

// Error satisfies the builtin error interface
func (e ReserveFailedItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReserveFailedItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReserveFailedItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReserveFailedItemValidationError{}

// Validate checks the field values on ReserveResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReserveResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReserveResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReserveResponseMultiError, or nil if none found.
func (m *ReserveResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReserveResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOkItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReserveResponseValidationError{
						field:  fmt.Sprintf("OkItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReserveResponseValidationError{
						field:  fmt.Sprintf("OkItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReserveResponseValidationError{
					field:  fmt.Sprintf("OkItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFailedItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReserveResponseValidationError{
						field:  fmt.Sprintf("FailedItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReserveResponseValidationError{
						field:  fmt.Sprintf("FailedItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReserveResponseValidationError{
					field:  fmt.Sprintf("FailedItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReserveResponseMultiError(errors)
	}

	return nil
}

// ReserveResponseMultiError is an error wrapping multiple validation errors
// returned by ReserveResponse.ValidateAll() if the designated constraints
// aren't met.
type ReserveResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReserveResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReserveResponseMultiError) AllErrors() []error { return m }

// ReserveResponseValidationError is the validation error returned by
// ReserveResponse.Validate if the designated constraints aren't met.
type ReserveResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReserveResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReserveResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReserveResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReserveResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReserveResponseValidationError) ErrorName() string { return "ReserveResponseValidationError" }

// Error satisfies the builtin error interface
func (e ReserveResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReserveResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReserveResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReserveResponseValidationError{}

// Validate checks the field values on ReleaseRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseRequestMultiError,
// or nil if none found.
func (m *ReleaseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOrderId() == nil {
		err := ReleaseRequestValidationError{
			field:  "OrderId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOrderId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseRequestValidationError{
					field:  "OrderId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseRequestValidationError{
					field:  "OrderId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseRequestValidationError{
				field:  "OrderId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReleaseRequestMultiError(errors)
	}

	return nil
}

// ReleaseRequestMultiError is an error wrapping multiple validation errors
// returned by ReleaseRequest.ValidateAll() if the designated constraints
// aren't met.
type ReleaseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseRequestMultiError) AllErrors() []error { return m }

// ReleaseRequestValidationError is the validation error returned by
// ReleaseRequest.Validate if the designated constraints aren't met.
type ReleaseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseRequestValidationError) ErrorName() string { return "ReleaseRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseRequestValidationError{}

// Validate checks the field values on ConfirmRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfirmRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfirmRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfirmRequestMultiError,
// or nil if none found.
func (m *ConfirmRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfirmRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOrderId() == nil {
		err := ConfirmRequestValidationError{
			field:  "OrderId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOrderId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfirmRequestValidationError{
					field:  "OrderId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfirmRequestValidationError{
					field:  "OrderId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfirmRequestValidationError{
				field:  "OrderId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfirmRequestMultiError(errors)
	}

	return nil
}

// ConfirmRequestMultiError is an error wrapping multiple validation errors
// returned by ConfirmRequest.ValidateAll() if the designated constraints
// aren't met.
type ConfirmRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfirmRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfirmRequestMultiError) AllErrors() []error { return m }

// ConfirmRequestValidationError is the validation error returned by
// ConfirmRequest.Validate if the designated constraints aren't met.
type ConfirmRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfirmRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfirmRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfirmRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfirmRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfirmRequestValidationError) ErrorName() string { return "ConfirmRequestValidationError" }

// Error satisfies the builtin error interface
func (e ConfirmRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfirmRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfirmRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfirmRequestValidationError{}
